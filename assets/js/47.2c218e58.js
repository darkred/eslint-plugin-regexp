(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{525:function(e,t,s){"use strict";s.r(t);var a=s(6),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"regexp-no-super-linear-move"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#regexp-no-super-linear-move"}},[e._v("#")]),e._v(" regexp/no-super-linear-move")]),e._v(" "),s("blockquote",[s("p",[e._v("disallow quantifiers that cause quadratic moves")])]),e._v(" "),s("ul",[s("li",[e._v("‚ùóÔ∏è "),s("badge",{attrs:{text:"This rule has not been released yet.",vertical:"middle",type:"error"}},[s("em",[s("strong",[e._v("This rule has not been released yet.")])])])],1)]),e._v(" "),s("h2",{attrs:{id:"rule-details"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rule-details"}},[e._v("#")]),e._v(" üìñ Rule Details")]),e._v(" "),s("p",[e._v("This rule reports super-linear worst-case runtime caused by a regex being moved across the input string. The reported cases are a problem because the super-linear worst-case runtime can be exploited by attackers in what is called "),s("a",{attrs:{href:"https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS",target:"_blank",rel:"noopener noreferrer"}},[e._v("Regular expression Denial of Service - ReDoS"),s("OutboundLink")],1),e._v(".")]),e._v(" "),s("eslint-code-block",[s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('/* eslint regexp/no-super-linear-move: "error" */')]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* ‚úì GOOD */")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" foo "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("abc|def")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" foo "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("\\ba+b")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" foo "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("^\\s*foo:")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" foo "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("ab+")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" foo "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("#.*")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* ‚úó BAD */")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" foo "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("a+b")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" foo "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("^\\s*foo:")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-flags"}},[e._v("m")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" foo "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("<.*?>")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])])]),e._v(" "),s("h3",{attrs:{id:"background"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#background"}},[e._v("#")]),e._v(" Background")]),e._v(" "),s("p",[e._v("Regexes are often used to find text of within a string (e.g. "),s("code",[e._v('/abc/.exec("123 abc def")')]),e._v("). The position of the matching text is unknown and has to be determined by the regex engine. In practice, the regex engine will move the regex across the input string character by character. While there are many optimizations to skip parts of the input string, there will still be "),s("em",[e._v("O(n)")]),e._v(" possible positions. If there is no text matching the regex in the input string, then all "),s("em",[e._v("O(n)")]),e._v(" positions will be checked.")]),e._v(" "),s("p",[e._v("This is not problem in it self, "),s("em",[e._v("O(n)")]),e._v(" is expected for linear string searching algorithms.")]),e._v(" "),s("p",[e._v("Problems arise when the regex itself takes more than "),s("em",[e._v("O(1)")]),e._v(" steps (on average) to reject any position within the input.")]),e._v(" "),s("p",[e._v("Example: The regex "),s("code",[e._v("/^a+b/")]),e._v(" takes "),s("em",[e._v("O(n)")]),e._v(" steps to find no match in an input of "),s("em",[e._v("n")]),e._v("-many "),s("code",[e._v("a")]),e._v("s. However, the regex "),s("code",[e._v("/a+b/")]),e._v(" (no assertion) takes "),s("em",[e._v("O(n)")]),e._v(" steps to find no match in the same input at position 0. It will take another "),s("em",[e._v("O(n-1)")]),e._v(" steps at position 1, another "),s("em",[e._v("O(n-2)")]),e._v(" steps at position 2, and so on. In total, "),s("code",[e._v("/a+b/")]),e._v(" will take "),s("em",[e._v("O(n^2)")]),e._v(" steps to find no match in an input of "),s("em",[e._v("n")]),e._v("-many "),s("code",[e._v("a")]),e._v("s.")]),e._v(" "),s("p",[e._v("If a regex is moved across the string and takes "),s("em",[e._v("O(n)")]),e._v(" steps (on average) to reject each of the "),s("em",[e._v("O(n)")]),e._v(" possible positions, then it will reject the input string in "),s("em",[e._v("O(n^2)")]),e._v(" steps.")]),e._v(" "),s("h3",{attrs:{id:"possible-fixes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#possible-fixes"}},[e._v("#")]),e._v(" Possible fixes")]),e._v(" "),s("p",[e._v("There are multiple ways to fix this kind of super-linear runtime.")]),e._v(" "),s("p",[e._v("However, there is no one-site-fits-all solution. Adequate testing and code review are necessary to ensure that the fixed regex is still correct.")]),e._v(" "),s("h4",{attrs:{id:"change-the-quantifier"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#change-the-quantifier"}},[e._v("#")]),e._v(" Change the quantifier")]),e._v(" "),s("p",[e._v("If the quantifier is preceded by an assertion, the quantifier might be too broad (= accept too many characters). Narrowing down the quantifier might fix the issue.")]),e._v(" "),s("p",[e._v("Example: "),s("code",[e._v("/^\\s*(\\w+)\\s*[:=]/m")])]),e._v(" "),s("p",[e._v("This is a simple regex to find keys in a config file. Keys must be at the start of a line and may be surrounded by whitespace characters.")]),e._v(" "),s("p",[e._v("This rule says that the first "),s("code",[e._v("\\s*")]),e._v(' causes quadratic runtime for "any attack string '),s("code",[e._v("/[\\n\\r\\u2028\\u2029]+/")]),e._v('."')]),e._v(" "),s("p",[e._v("The problem with "),s("code",[e._v("\\s*")]),e._v(" is that "),s("code",[e._v("\\s")]),e._v(" also allows line break characters (the characters in the attack string). "),s("code",[e._v("^")]),e._v(' already ensures the "start of a line" requirement, so there is no reason to allow line breaks after the '),s("code",[e._v("^")]),e._v(".")]),e._v(" "),s("p",[e._v("The fix is to remove all line break characters from "),s("code",[e._v("\\s")]),e._v(". This is difficult, so let's cheat a little and say that only spaces and tabs ("),s("code",[e._v("[\\t ]")]),e._v(") are allows to surround the key.")]),e._v(" "),s("eslint-code-block",[s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('/* eslint regexp/no-super-linear-move: "error" */')]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* ‚úó BAD */")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" example "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("^\\s*(\\w+)\\s*[:=]")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-flags"}},[e._v("m")])]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* ‚úì FIXED */")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" fix "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("^[\\t ]*(\\w+)[\\t ]*[:=]")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-flags"}},[e._v("m")])]),e._v("\n")])])])]),e._v(" "),s("h4",{attrs:{id:"limit-the-quantifier"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#limit-the-quantifier"}},[e._v("#")]),e._v(" Limit the quantifier")]),e._v(" "),s("p",[e._v("All quantifiers reported by this rule are unbound (= maximum is infinite). This is because attackers need strings with a lengths >1000 character to exploit the quadratic runtime.")]),e._v(" "),s("p",[e._v("If the quantifier simply stops searching after some maximum number of steps, the quantifier isn't exploitable.")]),e._v(" "),s("p",[e._v("Note: The maximum of the quantifier should be reasonably small (typically <100). Choosing a large maximum (>1000) will cause the quantifier to be exploitable despite the limit.")]),e._v(" "),s("p",[e._v("Example: "),s("code",[e._v("/((?:\\\\{2})*)(\\\\?)\\|/g")])]),e._v(" "),s("p",[e._v("This regex "),s("strong",[e._v("was")]),e._v(" used by "),s("a",{attrs:{href:"https://github.com/isaacs/minimatch",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("minimatch")]),s("OutboundLink")],1),e._v(" to find escaped and unescaped "),s("code",[e._v("|")]),e._v(" characters.")]),e._v(" "),s("p",[e._v("This rule says that the "),s("code",[e._v("(?:\\\\{2})*")]),e._v(' causes quadratic runtime for "any attack string '),s("code",[e._v("/(?:\\\\{2})+/")]),e._v('."')]),e._v(" "),s("p",[e._v("The fix is to limit the "),s("code",[e._v("(?:\\\\{2})*")]),e._v(" quantifier. "),s("code",[e._v("minimatch")]),e._v(" limited it to at most 64 repetitions. You read more about this vulnerability "),s("a",{attrs:{href:"https://medium.com/node-security/minimatch-redos-vulnerability-590da24e6d3c",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),s("OutboundLink")],1),e._v(".")]),e._v(" "),s("eslint-code-block",[s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('/* eslint regexp/no-super-linear-move: "error" */')]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* ‚úó BAD */")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" example "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("((?:\\\\{2})*)(\\\\?)\\|")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-flags"}},[e._v("g")])]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* ‚úì FIXED */")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" fix "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("((?:\\\\{2}){0,64})(\\\\?)\\|")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-flags"}},[e._v("g")])]),e._v("\n")])])])]),e._v(" "),s("h4",{attrs:{id:"add-an-assertion"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#add-an-assertion"}},[e._v("#")]),e._v(" Add an assertion")]),e._v(" "),s("p",[e._v("Adding a lookbehind, "),s("code",[e._v("\\b")]),e._v(", or "),s("code",[e._v("^")]),e._v(" assertion at the start of the pattern can solve a lot of issues.")]),e._v(" "),s("p",[e._v("This fix is typically only applicable if the exploitable quantifier can consume exactly one character per iteration. Quantifiers that can consume more than character per iteration (e.g. "),s("code",[e._v("(?:abc)+")]),e._v(", "),s("code",[e._v("(?:ab?)+")]),e._v(") are very difficult to fix with this approach.")]),e._v(" "),s("p",[e._v("Example: "),s("code",[e._v("/[a-z_][a-z_0-9]*(?=\\s*\\()/i")])]),e._v(" "),s("p",[e._v("This is a simple regex to find the names of functions and function-like macros in a C program.")]),e._v(" "),s("p",[e._v("This rule says that the first "),s("code",[e._v("[a-z_0-9]*")]),e._v(' causes quadratic runtime for "any attack string '),s("code",[e._v("/[A-Z_]+/i")]),e._v('."')]),e._v(" "),s("p",[e._v("The problem is that "),s("code",[e._v("[a-z_][a-z_0-9]*")]),e._v(" isn't guaranteed to start at the start of the function name, the "),s("code",[e._v("[a-z_]")]),e._v(" can also match anywhere inside the function name.")]),e._v(" "),s("p",[e._v("The fix is to add an assertion to make sure that "),s("code",[e._v("[a-z_]")]),e._v(" matches the first character of a name. We can use the lookbehind "),s("code",[e._v("(?<![a-z_0-9])")]),e._v(" == "),s("code",[e._v("(?<!\\w)")]),e._v(". In this case, it's also possible to use the built-in "),s("code",[e._v("\\b")]),e._v(" assertion.")]),e._v(" "),s("p",[e._v("Note that using "),s("code",[e._v("(?<![a-z_])")]),e._v(" is not enough. "),s("code",[e._v("(?<![a-z_])[a-z_]")]),e._v(" can still match in the middle of the name for names with numbers (e.g. "),s("code",[e._v("str2int")]),e._v("). The lookbehind has to disallow the characters of the quantifier "),s("code",[e._v("[a-z_0-9]*")]),e._v(".")]),e._v(" "),s("eslint-code-block",[s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('/* eslint regexp/no-super-linear-move: "error" */')]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* ‚úó BAD */")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" example "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("[a-z_][a-z_0-9]*(?=\\s*\\()")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-flags"}},[e._v("i")])]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* ‚úì FIXED */")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" fix1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("(?<![a-z_0-9])[a-z_][a-z_0-9]*(?=\\s*\\()")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-flags"}},[e._v("i")])]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" fix2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("(?<!\\w)[a-z_][a-z_0-9]*(?=\\s*\\()")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-flags"}},[e._v("i")])]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("var")]),e._v(" fix3 "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("\\b[a-z_][a-z_0-9]*(?=\\s*\\()")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-flags"}},[e._v("i")])]),e._v("\n")])])])]),e._v(" "),s("h3",{attrs:{id:"limitations-of-this-rule"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#limitations-of-this-rule"}},[e._v("#")]),e._v(" Limitations of this rule")]),e._v(" "),s("p",[e._v("This rule implements a simple detection method. It is unable to find certain cases.")]),e._v(" "),s("p",[e._v("This means that this rule might not be able to verify fixed regexes. This rule might be unable to detect that supposedly fixed regexes are actually still vulnerable.")]),e._v(" "),s("h2",{attrs:{id:"options"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#options"}},[e._v("#")]),e._v(" üîß Options")]),e._v(" "),s("div",{staticClass:"language-json extra-class"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"regexp/no-super-linear-move"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"error"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"report"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"certain"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"ignoreSticky"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),s("h3",{attrs:{id:"report-certain-potential"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#report-certain-potential"}},[e._v("#")]),e._v(" "),s("code",[e._v('report: "certain" | "potential"')])]),e._v(" "),s("p",[e._v("This option has the same function as the "),s("RouterLink",{attrs:{to:"/rules/no-super-linear-backtracking.html#report"}},[s("code",[e._v("report")]),e._v(" option of "),s("code",[e._v("regexp/no-super-linear-backtracking")])]),e._v(". The default value is "),s("code",[e._v('"certain"')]),e._v(".")],1),e._v(" "),s("h3",{attrs:{id:"ignoresticky-boolean"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ignoresticky-boolean"}},[e._v("#")]),e._v(" "),s("code",[e._v("ignoreSticky: boolean")])]),e._v(" "),s("p",[e._v("By default, this rule ignores regexes with the sticky ("),s("code",[e._v("y")]),e._v(") flag. These regexes do not move across the input string on their own and they are mostly immune to this type of super-linear worst-case because of that. However, some algorithms (and even built-in JavaScript functions) manually move regexes across the string and others change the flags of regexes.")]),e._v(" "),s("p",[e._v("This option determines whether this rule will ignore regexes with sticky ("),s("code",[e._v("y")]),e._v(") flag.")]),e._v(" "),s("ul",[s("li",[s("p",[s("code",[e._v("ignoreSticky: true")]),e._v("  ("),s("em",[e._v("default")]),e._v(")")]),e._v(" "),s("p",[e._v("Regexes with the sticky ("),s("code",[e._v("y")]),e._v(") flag will be ignored.")])]),e._v(" "),s("li",[s("p",[s("code",[e._v("ignoreSticky: false")])]),e._v(" "),s("p",[e._v("All regexes will be analysed.")])])]),e._v(" "),s("h3",{attrs:{id:"ignorepartial-boolean"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ignorepartial-boolean"}},[e._v("#")]),e._v(" "),s("code",[e._v("ignorePartial: boolean")]),e._v(":")]),e._v(" "),s("p",[e._v("Some regexes are used as fragments to build more complex regexes. Example:")]),e._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" fn "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("\\w+(?=\\s*\\()")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("source"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" pattern "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("RegExp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[e._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("#\\\\s*define\\\\s+")]),s("span",{pre:!0,attrs:{class:"token interpolation"}},[s("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[e._v("${")]),e._v("fn"),s("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[e._v("}")])]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[e._v("`")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"g"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("p",[e._v("Even if a fragment had exploitable quantifiers, it might not cause super-linear runtime depending on how the fragment is used.")]),e._v(" "),s("ul",[s("li",[s("p",[s("code",[e._v("ignorePartial: true")]),e._v("  ("),s("em",[e._v("default")]),e._v(")")]),e._v(" "),s("p",[e._v("The rule does not check regexes used as a fragment. It assumes that fragments are used in a way such that super-linear runtime caused by moves is prevented.")])]),e._v(" "),s("li",[s("p",[s("code",[e._v("ignorePartial: false")])]),e._v(" "),s("p",[e._v("The rule checks all regexes regardless of how they are used.")])])]),e._v(" "),s("h2",{attrs:{id:"further-reading"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#further-reading"}},[e._v("#")]),e._v(" üìö Further reading")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS",target:"_blank",rel:"noopener noreferrer"}},[e._v("Regular expression Denial of Service - ReDoS"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/RunDevelopment/scslre",target:"_blank",rel:"noopener noreferrer"}},[e._v("scslre"),s("OutboundLink")],1)])]),e._v(" "),s("h2",{attrs:{id:"implementation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" üîç Implementation")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://github.com/ota-meshi/eslint-plugin-regexp/blob/master/lib/rules/no-super-linear-move.ts",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rule source"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/ota-meshi/eslint-plugin-regexp/blob/master/tests/lib/rules/no-super-linear-move.ts",target:"_blank",rel:"noopener noreferrer"}},[e._v("Test source"),s("OutboundLink")],1)])])],1)}),[],!1,null,null,null);t.default=r.exports}}]);